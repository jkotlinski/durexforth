<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2. Tutorial</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="index.html" title="durexForth: Operators Manual" /><link rel="up" href="index.html" title="durexForth: Operators Manual" /><link rel="prev" href="ar01s01.html" title="1. Introduction" /><link rel="next" href="ar01s03.html" title="3. Editor" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ar01s01.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s03.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_tutorial"></a>2. Tutorial</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_interpreter"></a>2.1. Interpreter</h3></div></div></div><p>Start up durexForth. When loaded, it will greet you with a blinking yellow cursor, waiting for your input. You have landed in the interpreter!</p><p>Let’s warm it up a little. Enter <code class="literal">1</code> (followed by return). You have now put a digit on the stack. This can be verified by the command <code class="literal">.s</code>, which will print the stack contents without modifying it. Now enter <code class="literal">.</code> to pop the digit and print it to screen, followed by <code class="literal">.s</code> to verify that the stack is empty.</p><p>Let’s define a word <code class="literal">bg!</code> for setting the border color…</p><pre class="screen">: bg! $d020 c! ;</pre><p>Now try entering <code class="literal">1 bg!</code> to change the border color to white.
Then, try changing it back again with <code class="literal">0 bg!</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_introducing_the_editor"></a>2.2. Introducing the Editor</h3></div></div></div><p>The v editor is convenient for editing larger pieces of code. With it, you keep an entire source file loaded in RAM, and you can recompile and test it easily.</p><p>Start the editor by typing <code class="literal">v</code>. You will enter the red editor screen. To enter text, first press <code class="literal">i</code> to enter insert mode. This mode allows you to insert text into the buffer. You can see that it’s active on the <code class="literal">I</code> that appears in the lower left corner. This is a good start for creating a program!</p><p>Now, enter the following lines…</p><pre class="screen">: flash begin 1 $d020 +! again ; flash</pre><p>…and then press ← to leave insert mode.
Press <span class="emphasis"><em>F7</em></span> to compile and run. If everything is entered right, you will see a beautiful color cycle.</p><p>When you finished watching, press <span class="emphasis"><em>RESTORE</em></span> to quit your program, then enter <code class="literal">v</code> to reopen the editor.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_assembler"></a>2.3. Assembler</h3></div></div></div><p>If you want to color cycle as fast as possible, it is possible to use the durexForth assembler to generate machine code. <code class="literal">code</code> and <code class="literal">;code</code> define a code word, just like <code class="literal">:</code> and <code class="literal">;</code> define Forth words. Within a code word, you can use assembler mnemonics.</p><pre class="screen">code flash
here ( push current addr )
$d020 inc,
jmp, ( jump to pushed addr )
;code
flash</pre><p>It is also possible to use inline assembly within regular Forth words:</p><pre class="screen">: flash begin [ $d020 inc, ] again ;
flash</pre><p>Note: As the <code class="literal">x</code> register contains the parameter stack depth, it is important that your assembly code leaves it unchanged.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_console_i_o_example"></a>2.4. Console I/O Example</h3></div></div></div><p>This piece of code reads from keyboard and sends back the chars to screen:</p><pre class="screen">: foo key emit recurse ;
foo</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_printer_example"></a>2.5. Printer Example</h3></div></div></div><p>This piece of code prints a message to a printer on device #4, and then prints a message to the screen:</p><pre class="screen">include io

: print-hello
4 device ( use device 4 )
0 0 47 7 open ioabort ( open address 7 as file 47, abort on failure )
47 chkout ioabort ( redirect output to file 47, abort on failure )
." Hello, printer!" cr
clrchn ( stop input and output redirection )
." Hello, screen!" cr
47 close ( close file 47 ) ;

print-hello</pre><p>The device number and address may differ between printer models. Commodore MPS series printers use address 0 to print in their uppercase/graphics font, and address 7 to print in their lowercase/uppercase font.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_avoiding_stack_crashes"></a>2.6. Avoiding Stack Crashes</h3></div></div></div><p>Stack overflow and underflow are common causes for errors and crashes.
Simply put, the data stack must not contain too many or too few items.
This section describes some techniques to avoid such errors.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_commenting"></a>Commenting</h4></div></div></div><p>One helpful technique to avoid stack crashes is to add comments about stack usage.
In this example, we imagine a graphics word "drawbox" that draws a black box.
<code class="literal">( color — )</code> indicates that it takes one argument on stack, and on exit it should
leave nothing on the stack. The comments inside the word (starting with £) indicate what the stack
looks like after the line has executed.</p><pre class="screen">: drawbox ( color -- )
10 begin dup 20 &lt; while £ color x
10 begin dup 20 &lt; while £ color x y
2dup £ color x y x y
4 pick £ color x y x y color
blkcol £ color x y
1+ repeat drop £ color x
1+ repeat 2drop ;</pre><p>Once the word is working as supposed, it may be nice to again remove the comments, as
they are no longer very interesting to read.</p><p>Note: The Forth standard defines backslash (\) as the line comment character, but the C64 lacks a real backslash. Moreover, ASCII \ and PETSCII £ both map to $5c. Therefore, the £ character is used as a substitution on the C64.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_stack_checks"></a>Stack Checks</h4></div></div></div><p>Another useful technique during development is to check at the end of your main loop
that the stack depth is what you expect it to. This will catch stack underflows
and overflows.</p><pre class="screen">: mainloop begin
( do stuff here... )
depth abort" depth not 0"
again ;</pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s01.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s03.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>