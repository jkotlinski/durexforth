=== Stack Manipulation

((drop)) _( a -- )_ :: Drop top of stack.
((dup)) _( a -- a a )_ :: Duplicate top of stack.
((swap)) _( a b -- b a )_ :: Swap top stack elements.
((over)) _( a b -- a b a )_ :: Make a copy of the second item and push it on top.
((rot)) _( a b c -- b c a )_ :: Rotate the third item to the top.
((-rot)) _( a b c -- c a b )_ :: rot rot
((2drop)) _( a b -- )_ :: Drop two topmost stack elements.
((2dup)) _( a b -- a b a b )_ :: Duplicate two topmost stack elements.
((?dup)) _( a -- a a? )_ :: Dup a if a differs from 0.
((nip))	_( a b -- b )_ :: swap drop
((tuck)) _( a b -- b a b )_ :: dup -rot
((pick)) _( x~u~ ... x~1~ x~0~ u -- x~u~ ... x~1~ x~0~ x~u~ )_ :: Pick from stack element with depth u to top of stack.
((>r)) _( a -- )_ :: Move value from top of parameter stack to top of return stack.
((r>)) _( -- a )_ :: Move value from top of return stack to top of parameter stack.
((r@)) _( -- a )_ :: Copy value from top of return stack to top of parameter stack.
((depth)) _( -- n)_ :: +n+ is the number of single-cell values contained in the data stack before +n+ was placed on the stack.
((lsb)) _( -- addr)_ :: The top address of the LSB parameter stack.
((msb)) _( -- addr)_ :: The top address of the MSB parameter stack.

=== Utility

((.)) _( n -- )_ :: Prints top value of stack as signed number.
((u.)) _( u -- )_ :: Prints top value of stack as unsigned number.
((.s)) :: See stack contents.
((emit)) _( a -- )_ :: Prints top value of stack as a PETSCII character. Example: `q emit`
((&pound;)) :: Comment to end of line. (Used on C64/PETSCII.)
((\\)) :: Comment to end of line. (Used when cross-compiling from PC/ASCII.)
((pass:[(])) :: Multiline comment. Ignores everything until a ).
((bl)) _( -- char )_ :: Gives the PETSCII character for a space.
((space)) :: Displays one space.
((spaces)) _( n -- )_ :: Displays n spaces.
((page)) :: Clears the screen.
((rvs)) :: Reverse screen output.

=== Mathematics

((1+)) _( a -- b )_ :: Increase top of stack value by 1.
((1-)) _( a -- b )_ :: Decrease top of stack value by 1.
((2+)) _( a -- b )_ :: Increase top of stack value by 2.
((2*)) _( a -- b )_ :: Multiply top of stack value by 2.
((2/)) _( a -- b )_ :: Divide top of stack value by 2.
((100/)) _( a -- b )_ :: Divides top of stack value by $100.
((+!)) _( n a -- )_ :: Add n to memory address a.
((+)) _( a b -- c )_ :: Add a and b.
((-)) _( a b -- c )_ :: Subtract b from a.
((*)) _( a b -- c )_ :: Multiply a with b.
((/)) _( a b -- q )_ :: Divide a with b using floored division.
((/mod)) _( a b -- r q )_ :: Divide a with b, giving remainder r and quotient q.
((mod)) _( a b -- r )_ :: Remainder of a divided by b.
((*/)) _( a b c -- q )_ :: Multiply a with b, then divide by c, using a 32-bit intermediary.
((*/mod)) _( a b c -- r q )_ :: Like */, but also keeping remainder r.
((0<)) _( a -- b )_ :: Is a negative?
((negate)) _( a -- b )_ :: Negates a.
((abs)) _( a -- b )_ :: Gives absolute value of a.
((min)) _( a b -- c )_ :: Gives the lesser of a and b.
((max)) _( a b -- c )_ :: Gives the greater of a and b.
((within)) _( n lo hi -- flag )_ :: Returns true if lo &le; n < hi.
((<)) _( n1 n2 -- flag )_ :: Is n1 less than n2? (Signed.)
((>)) _( n1 n2 -- flag )_ :: Is n1 greater than n2? (Signed.)
((u<)) _( u1 u2 -- flag )_ :: Is u1 less than u2? (Unsigned.)
((u>)) _( u1 u2 -- flag )_ :: Is u1 greater than u2? (Unsigned.)
((lshift)) _( a b -- c )_ :: Binary shift a left by b.
((rshift)) _( a b -- c )_ :: Binary shift a right by b.
((base)) _(variable)_ :: Points to the cell that holds the numerical base.
((decimal)) :: Sets the numerical base to 10.
((hex)) :: Sets the numerical base to 16.

=== Double

The following words use double-cell integers. On the stack, the cell containing the most significant part of a double-cell integer is above the cell containing the least significant part.

((dabs)) _( d -- ud )_ :: Produces the absolute value of _d_.
((dnegate)) _( d -- d )_ :: Negates the double-cell integer _d_.
((s>d)) _( n -- d )_ :: Converts the number n to the double-cell number _d_.
((m+)) _( d n -- d )_ :: Add _n_ to double-cell number _d_.
((m*)) _( a b -- d )_ :: Multiply _a_ with _b_, producing a double-cell value.
((um*)) _( a b -- ud )_ :: Multiply _a_ with _b_, giving the unsigned double-cell number _ud_.
((um/mod)) _( ud n -- r q )_ :: Divide double-cell number ud by n, giving remainder r and quotient q. Values are unsigned.
((fm/mod)) _( d n -- r q )_ :: Divide double-cell number d by n, giving the floored quotient q and the remainder r. Values are signed.

=== Logic

((0=)) _( a -- flag)_ :: Is _a_ equal to zero?
((0<>)) _( a -- flag )_ :: Is _a_ not equal to 0?
((\=)) _( a b -- flag )_ :: Is _a_ equal to _b_?
((<>)) _( a b -- flag )_ :: Does _a_ differ from _b_?
((and)) _( a b -- c )_ :: Binary and.
((or)) _( a b -- c )_ :: Binary or.
((xor)) _( a b -- c )_ :: Binary exclusive or.
((invert)) _( a -- b )_ :: Flip all bits of _a_.

=== Memory

((!)) _( value address -- )_ :: Store 16-bit value at address.
((@)) _( address -- value )_ :: Fetch 16-bit value from address.
((c!)) _( value address -- )_ :: Store 8-bit value at address.
((c@)) _( address -- value )_ :: Fetch 8-bit value from address.
((fill)) _( addr len char -- )_ :: Fill range [addr, len + addr) with char.
((move)) _( src dst len -- )_ :: Copies a region of memory `len` bytes long, starting at `src`, to memory beginning at `dst`.

=== Compiling

((:)) _( "name" -- )_ :: Define the word with the given name and enter compilation state.
((:noname)) _( -- xt )_ :: Create an execution token and enter compilation state.
((;)) _( -- )_ :: End the current definition, allow it to be found in the dictionary and go back to interpretation state.
((code)) _( "name" -- )_ :: Start assembling a new word.
((;code))  :: End assembler.
((\,)) _( n -- )_ :: Write word on stack to `here` position and increase `here` by 2.
((c,)) _( n -- )_ :: Write byte on stack to `here` position and increase `here` by 1.
((allot)) _( n -- )_ :: Add _n_ bytes to the body of the most recently defined word.
((literal)) _( n -- )_ :: Compile a value from the stack as a literal value. Typical use: `: x ... [ a b * ] literal ... ;`
(([char])) _( "c" -- )_ :: Compile character _c_ as a literal value.
(([)) _( -- )_ :: Leave compile mode. Execute the following words immediately instead of compiling them.
((])) _( -- )_ :: Return to compile mode.
((immediate::)) Mark the most recently defined word as immediate (i.e. inside colon definitions, it will be executed immediately instead of compiled).
((['])) name _( -- xt )_:: Place name's execution token xt on the stack.
The execution token returned by the compiled phrase +[\'] x+ is the same value returned by +' x+ outside of compilation state.
Typical use: +: x ... ['] name ... ;+
((compile,)) ( xt -- ) :: Append \texttt{jsr xt} to the word being compiled. Typical use: +: recurse immed latest >xt compile, ;+
((postpone)) _xxx_ :: Compile the compilation semantics (instead of interpretation semantics) of xxx. Typical use:
----
: endif postpone then ; immediate
: x ... if ... endif ... ;
----
((header)) _( "name" -- )_ :: Create a dictionary header named _name_.
((create)) _( "name" -- )_ ... does> :: Create a word-creating word named _name_ with custom behavior specified after `does>`.  For further description, see "Starting Forth."
((state)) _( -- addr)_ :: _addr_ is the address of a cell containing the compilation-state flag. It is 1 when compiling, otherwise 0.

=== Word List

((hide)) _( "name" -- )_:: Remove _name_ from the word list, while leaving its definition in place.
((define)) _( "name" -- )_:: Assign `here` as the execution token of word _name_ and enter the compilation state.
((defcode)) _( "name" -- )_:: Like `define`, but starts a `code` segment instead.

=== Variables

==== Values

Values are fast to read, slow to write.
Use values for variables that are rarely changed.

_1_ ((value)) _foo_:: Create value _foo_ and set it to _1_.
_2_ ((constant)) _bar_:: Create constant value _bar_ and set it to _2_.
_foo_:: Fetch value of _foo_.
_0_ ((to)) _foo_:: Set _foo_ to _0_.

==== Variables

Variables are faster to write to than values.

((variable)) _bar_:: Define variable _bar_.
_bar_ ((@)):: Fetch value of variable _bar_.
_1 bar_ ((!)):: Set variable _bar_ to _1_.

=== Control Flow

Control functions only work in compile mode, not in interpreter.

((if)) ... ((then)) :: condition IF true-part THEN rest

if ... ((else)) ... then :: condition IF true-part ELSE false-part THEN rest

((do)) .. ((loop)) :: Start a loop with index and limit. Example:

----
: print0to7 8 0 do i . loop ;
----

((do)) .. ((+loop)) :: Start a loop with a custom increment. Example:

----
( prints odd numbers from 1 to n )
: printoddnumbers (n -- ) 1 do i . 2 +loop ;
----

((i)), ((j)) :: Variables to be used inside `do` .. `loop` constructs. `i` gives inner loop index, `j` gives outer loop index.

((leave)) :: Leaves the innermost loop.

((unloop)) :: Discards the loop-control parameters. Allows clean <<exit>> from within a loop.

----
: xx 0 0 do unloop exit loop ;
----

((begin)) .. ((again)) :: Infinite loop.

((begin)) .. ((until)) :: BEGIN loop-part condition UNTIL. Loop until condition is true.

((begin)) .. ((while)) .. ((repeat)) :: BEGIN condition WHILE loop-part REPEAT. Repeat loop-part while condition is true.

[[exit]] ((exit)) :: Exit function. Typical use: `: X test IF EXIT THEN ... ;`

((recurse)) :: Jump to the start of the word being compiled.

((case)) .. ((endcase)), ((of)) .. ((endof)) :: Switch statements.

----
: tellno ( n -- )
case
1 of ." one" endof
2 of ." two" endof
3 of ." three" endof
     ." other" endcase ;
----

=== Input

((key)) _( -- c )_ :: Gets one character from the keyboard.
((key?)) _( -- flag )_ :: Returns true if a character is available for `key`.
((getc)) _( -- c )_ :: Consumes the next character from the input buffer and increases `>in` by one. If no characters are available, the input buffer is refilled as needed.
((char)) _( -- c )_ :: Parses the next word, delimited by a space, and puts its first character on the stack.
((>in)) _( -- addr )_ :: Gives the address of a cell containing the offset in characters from the start of the input buffer to the start of the parse area.
((refill)) _( -- flag )_ :: Attempts to fill the input buffer from the input source, returning true if successful.
((source)) _( -- caddr u )_ :: Gives the address of, and number of characters in, the input buffer.
((source-id)) _( -- n )_ :: Returns 0 if current input is keyboard, -1 if it is a string from `evaluate`, or the current file id.
((word)) _( delim -- addr )_ :: Reads a word from input, using delimiter _delim_, and puts the string address on the stack. If the delimiter is the space character, non-breaking space (hex a0) will also be treated as a delimiter.
((parse-name)) _( name -- caddr u )_ :: Reads a word from input, delimited by whitespace. Skips leading spaces.
((interpret)) _( -- value )_ :: Interprets a word from input and puts it on the stack.
((accept)) _( addr u -- u )_ :: Receive a string of at most u characters into the buffer that starts at addr. Returns how many characters were received.
((evaluate)) _( addr len -- )_ :: Evaluate the given string.
((abort)) :: Empties the data stack and performs `quit`.
((abort")) _ccc" ( f -- )_  :: If _f_ is true, print _ccc_ and `abort`. Typical use: `: x ... test abort" error" ... ;`
((quit)) :: Enters an endless loop where DurexForth interprets Forth commands from the keyboard. The word is named "quit" since it can be used to quit a program. It also does cleanup tasks like resetting I/O.
