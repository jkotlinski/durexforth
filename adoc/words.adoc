=== Stack Manipulation

((drop)) _( a -- )_ :: Drop top of stack.
((dup)) _( a -- a a )_ :: Duplicate top of stack.
((swap)) _( a b -- b a )_ :: Swap top stack elements.
((over)) _( a b -- a b a )_ :: Make a copy of the second item and push it on top.
((rot)) _( a b c -- b c a )_ :: Rotate the third item to the top.
((-rot)) _( a b c -- c a b )_ :: rot rot
((2drop)) _( a b -- )_ :: Drop two topmost stack elements.
((2dup)) _( a b -- a b a b )_ :: Duplicate two topmost stack elements.
((?dup)) _( a -- a a? )_ :: Dup a if a differs from 0.
((nip))	_( a b -- b )_ :: swap drop
((tuck)) _( a b -- b a b )_ :: dup -rot
((pick)) _( x~u~ ... x~1~ x~0~ u -- x~u~ ... x~1~ x~0~ x~u~ )_ :: Pick from stack element with depth u to top of stack.
((>r)) _( a -- )_ :: Move value from top of parameter stack to top of return stack.
((r>)) _( -- a )_ :: Move value from top of return stack to top of parameter stack.
((r@)) _( -- a )_ :: Copy value from top of return stack to top of parameter stack.
((depth)) _( -- n)_ :: +n+ is the number of single-cell values contained in the data stack before +n+ was placed on the stack.
((lsb)) _( -- addr)_ :: The top address of the LSB parameter stack.
((msb)) _( -- addr)_ :: The top address of the MSB parameter stack.

=== Utility

((.)) _( n -- )_ :: Prints top value of stack as signed number.
((u.)) _( u -- )_ :: Prints top value of stack as unsigned number.
((.s)) :: See stack contents.
((emit)) _( a -- )_ :: Prints top value of stack as a PETSCII character. Example: `q emit`
((&pound;)) :: Comment to end of line. (Used on C64/PETSCII.)
((\\)) :: Comment to end of line. (Used when cross-compiling from PC/ASCII.)
((pass:[(])) :: Multiline comment. Ignores everything until a ).
((bl)) _( -- char )_ :: Gives the PETSCII character for a space.
((space)) :: Displays one space.
((spaces)) _( n -- )_ :: Displays n spaces.
((page)) :: Clears the screen.
((rvs)) :: Reverse screen output.

=== Mathematics

((1+)) _( a -- b )_ :: Increase top of stack value by 1.
((1-)) _( a -- b )_ :: Decrease top of stack value by 1.
((2+)) _( a -- b )_ :: Increase top of stack value by 2.
((2*)) _( a -- b )_ :: Multiply top of stack value by 2.
((2/)) _( a -- b )_ :: Divide top of stack value by 2.
((100/)) _( a -- b )_ :: Divides top of stack value by $100.
((+!)) _( n a -- )_ :: Add n to memory address a.
((+)) _( a b -- c )_ :: Add a and b.
((-)) _( a b -- c )_ :: Subtract b from a.
((*)) _( a b -- c )_ :: Multiply a with b.
((/)) _( a b -- q )_ :: Divide a with b using floored division.
((/mod)) _( a b -- r q )_ :: Divide a with b, giving remainder r and quotient q.
((mod)) _( a b -- r )_ :: Remainder of a divided by b.
((*/)) _( a b c -- q )_ :: Multiply a with b, then divide by c, using a 32-bit intermediary.
((*/mod)) _( a b c -- r q )_ :: Like */, but also keeping remainder r.
((0<)) _( a -- b )_ :: Is a negative?
((negate)) _( a -- b )_ :: Negates a.
((abs)) _( a -- b )_ :: Gives absolute value of a.
((min)) _( a b -- c )_ :: Gives the lesser of a and b.
((max)) _( a b -- c )_ :: Gives the greater of a and b.
((within)) _( n lo hi -- flag )_ :: Returns true if lo &le; n < hi.
((<)) _( n1 n2 -- flag )_ :: Is n1 less than n2? (Signed.)
((>)) _( n1 n2 -- flag )_ :: Is n1 greater than n2? (Signed.)
((u<)) _( u1 u2 -- flag )_ :: Is u1 less than u2? (Unsigned.)
((u>)) _( u1 u2 -- flag )_ :: Is u1 greater than u2? (Unsigned.)
((lshift)) _( a b -- c )_ :: Binary shift a left by b.
((rshift)) _( a b -- c )_ :: Binary shift a right by b.
((base)) _(variable)_ :: Points to the cell that holds the numerical base.
((decimal)) :: Sets the numerical base to 10.
((hex)) :: Sets the numerical base to 16.

=== Double

The following words use double-cell integers. On the stack, the cell containing the most significant part of a double-cell integer is above the cell containing the least significant part.

((dabs)) _( d -- ud )_ :: Produces the absolute value of _d_.
((dnegate)) _( d -- d )_ :: Negates the double-cell integer _d_.
((s>d)) _( n -- d )_ :: Converts the number n to the double-cell number _d_.
((m+)) _( d n -- d )_ :: Add _n_ to double-cell number _d_.
((m*)) _( a b -- d )_ :: Multiply _a_ with _b_, producing a double-cell value.
((um*)) _( a b -- ud )_ :: Multiply _a_ with _b_, giving the unsigned double-cell number _ud_.
((um/mod)) _( ud n -- r q )_ :: Divide double-cell number ud by n, giving remainder r and quotient q. Values are unsigned.
((fm/mod)) _( d n -- r q )_ :: Divide double-cell number d by n, giving the floored quotient q and the remainder r. Values are signed.

=== Logic

((0=)) _( a -- flag)_ :: Is _a_ equal to zero?
((0<>)) _( a -- flag )_ :: Is _a_ not equal to 0?
((\=)) _( a b -- flag )_ :: Is _a_ equal to _b_?
((<>)) _( a b -- flag )_ :: Does _a_ differ from _b_?
((and)) _( a b -- c )_ :: Binary and.
((or)) _( a b -- c )_ :: Binary or.
((xor)) _( a b -- c )_ :: Binary exclusive or.
((invert)) _( a -- b )_ :: Flip all bits of _a_.

=== Memory

((!)) _( value address -- )_ :: Store 16-bit value at address.
((@)) _( address -- value )_ :: Fetch 16-bit value from address.
((c!)) _( value address -- )_ :: Store 8-bit value at address.
((c@)) _( address -- value )_ :: Fetch 8-bit value from address.
((fill)) _( addr len char -- )_ :: Fill range [addr, len + addr) with char.
((move)) _( src dst len -- )_ :: Copies a region of memory `len` bytes long, starting at `src`, to memory beginning at `dst`.

=== Compiling

((:)) _( "name" -- )_ :: Define the word with the given name and enter compilation state.
((:noname)) _( -- xt )_ :: Create an execution token and enter compilation state.
((;)) _( -- )_ :: End the current definition, allow it to be found in the dictionary and go back to interpretation state.
((code)) _( "name" -- )_ :: Start assembling a new word.
((;code))  :: End assembler.
((\,)) _( n -- )_ :: Write word on stack to `here` position and increase `here` by 2.
((c,)) _( n -- )_ :: Write byte on stack to `here` position and increase `here` by 1.
((allot)) _( n -- )_ :: Add _n_ bytes to the body of the most recently defined word.
((literal)) _( n -- )_ :: Compile a value from the stack as a literal value. Typical use: `: x ... [ a b * ] literal ... ;`
(([char])) _( "c" -- )_ :: Compile character _c_ as a literal value.
(([)) _( -- )_ :: Leave compile mode. Execute the following words immediately instead of compiling them.
((])) _( -- )_ :: Return to compile mode.
((immediate::)) Mark the most recently defined word as immediate (i.e. inside colon definitions, it will be executed immediately instead of compiled).
((['])) name _( -- xt )_:: Place name's execution token xt on the stack.
The execution token returned by the compiled phrase +[\'] x+ is the same value returned by +' x+ outside of compilation state.
Typical use: +: x ... ['] name ... ;+
((compile,)) ( xt -- ) :: Append \texttt{jsr xt} to the word being compiled. Typical use: +: recurse immed latest >xt compile, ;+
((postpone)) _xxx_ :: Compile the compilation semantics (instead of interpretation semantics) of xxx. Typical use:
----
: endif postpone then ; immediate
: x ... if ... endif ... ;
----
((header)) _( "name" -- )_ :: Create a dictionary header named _name_.
((create)) _( "name" -- )_ ... does> :: Create a word-creating word named _name_ with custom behavior specified after `does>`.  For further description, see "Starting Forth."
((state)) _( -- addr)_ :: _addr_ is the address of a cell containing the compilation-state flag. It is 1 when compiling, otherwise 0.

=== Word List

((hide)) _( "name" -- )_:: Remove _name_ from the word list, while leaving its definition in place.
((define)) _( "name" -- )_:: Assign `here` as the execution token of word _name_ and enter the compilation state.
((defcode)) _( "name" -- )_:: Like `define`, but starts a `code` segment instead.
((dowords)) _( xt -- )_ :: Execute _xt_ once for every word in the word list, passing the name token of the word to _xt_, until the word list is exhausted or _xt_ returns false. The invoked _xt_ has the stack effect _( k * x nt -- l * x flag )_. If _flag_ is true, `dowords` will continue on to the next name, otherwise it will return.

----
\ from debug.fs
: (words) more name>string space 1 ;
: words ['] (words) dowords ;
----

((marker)) _( "name" -- )_ :: Creates a word that when called, forgets itself and all words that were defined after it. Example:

----
marker forget
: x ; forget
----

=== Variables

==== Values

Values are fast to read, slow to write.
Use values for variables that are rarely changed.

_1_ ((value)) _foo_:: Create value _foo_ and set it to _1_.
_2_ ((constant)) _bar_:: Create constant value _bar_ and set it to _2_.
_foo_:: Fetch value of _foo_.
_0_ ((to)) _foo_:: Set _foo_ to _0_.

==== Variables

Variables are faster to write to than values.

((variable)) _bar_:: Define variable _bar_.
_bar_ ((@)):: Fetch value of variable _bar_.
_1 bar_ ((!)):: Set variable _bar_ to _1_.

=== Control Flow

Control functions only work in compile mode, not in interpreter.

((if)) ... ((then)) :: condition IF true-part THEN rest

if ... ((else)) ... then :: condition IF true-part ELSE false-part THEN rest

((do)) .. ((loop)) :: Start a loop with index and limit. Example:

----
: print0to7 8 0 do i . loop ;
----

((do)) .. ((+loop)) :: Start a loop with a custom increment. Example:

----
( prints odd numbers from 1 to n )
: printoddnumbers (n -- ) 1 do i . 2 +loop ;
----

((i)), ((j)) :: Variables to be used inside `do` .. `loop` constructs. `i` gives inner loop index, `j` gives outer loop index.

((leave)) :: Leaves the innermost loop.

((unloop)) :: Discards the loop-control parameters. Allows clean <<exit>> from within a loop.

----
: x 0 0 do unloop exit loop ;
----

((begin)) .. ((again)) :: Infinite loop.

((begin)) .. ((until)) :: BEGIN loop-part condition UNTIL. Loop until condition is true.

((begin)) .. ((while)) .. ((repeat)) :: BEGIN condition WHILE loop-part REPEAT. Repeat loop-part while condition is true.

[[exit]] ((exit)) :: Exit function. Typical use: `: X test IF EXIT THEN ... ;`

((recurse)) :: Jump to the start of the word being compiled.

((case)) .. ((endcase)), ((of)) .. ((endof)) :: Switch statements.

----
: tellno ( n -- )
case
1 of ." one" endof
2 of ." two" endof
3 of ." three" endof
     ." other" endcase ;
----

=== Input

((key)) _( -- c )_ :: Gets one character from the keyboard.
((key?)) _( -- flag )_ :: Returns true if a character is available for `key`.
((getc)) _( -- c )_ :: Consumes the next character from the input buffer and increases `>in` by one. If no characters are available, the input buffer is refilled as needed.
((char)) _( -- c )_ :: Parses the next word, delimited by a space, and puts its first character on the stack.
((>in)) _( -- addr )_ :: Gives the address of a cell containing the offset in characters from the start of the input buffer to the start of the parse area.
((refill)) _( -- flag )_ :: Attempts to fill the input buffer from the input source, returning true if successful.
((source)) _( -- caddr u )_ :: Gives the address of, and number of characters in, the input buffer.
((source-id)) _( -- n )_ :: Returns 0 if current input is keyboard, -1 if it is a string from `evaluate`, or the current file id.
((word)) _( delim -- addr )_ :: Reads a word from input, using delimiter _delim_, and puts the string address on the stack. If the delimiter is the space character, non-breaking space (hex a0) will also be treated as a delimiter.
((parse-name)) _( name -- caddr u )_ :: Reads a word from input, delimited by whitespace. Skips leading spaces.
((interpret)) _( -- value )_ :: Interprets a word from input and puts it on the stack.
((accept)) _( addr u -- u )_ :: Receive a string of at most u characters into the buffer that starts at addr. Returns how many characters were received.
((evaluate)) _( addr len -- )_ :: Evaluate the given string.
((abort)) :: Empties the data stack and performs `quit`.
((abort")) _ccc" ( f -- )_  :: If _f_ is true, print _ccc_ and `abort`. Typical use: `: x ... test abort" error" ... ;`
((quit)) :: Enters an endless loop where DurexForth interprets Forth commands from the keyboard. The word is named "quit" since it can be used to quit a program. It also does cleanup tasks like resetting I/O.

=== Strings

((.()) :: Print a string. Example: `.( foo)`
((.")) :: Compile-time version of `.(`. Example: `: foo ." bar" ;`
((s")) _( -- caddr u )_ :: Define a string. Compile-time only! Example: `s" foo"`.
((count)) _( str -- caddr u )_ :: Returns data address and length of the counted string _str_.
((type)) _( caddr u -- )_ :: Prints a string.
((/string)) _( caddr u n -- caddr+n u-n )_ :: Adjusts the string by _n_ characters.

=== Number Formatting

For more info about number formatting, read Starting Forth.

((<#)) :: Begins the number conversion process.
((#)) _( ud -- ud )_ :: Converts one digit and puts it in the start of the output string.
((#s)) _( ud -- ud )_ :: Calls `#` and repeats until _ud_ is zero.
((hold)) _( ch -- )_ :: Inserts the character `ch` at the start of the output string.
((sign)) _( a -- )_ :: If _a_ is negative, inserts a minus sign at the start of the output string.
((#>)) _( xd -- addr u )_ :: Drops _xd_ and returns the output string.

=== Vectored Execution

((')) _( "name" -- addr )_ :: Find execution token of the word named _name_.
((find)) _( cstr -- cstr 0 | xt -1 | xt 1 )_ :: Find the definition named in the counted string _cstr_.
If the definition is not found, return _cstr_ and 0, otherwise return the execution token.
If the definition is immediate, also return 1, otherwise also return -1.
((find-name)) _( caddr u -- 0 | nt )_ :: Get the name token (dictionary pointer) of the word named by _caddr u_, or 0 if the word is not found.
((execute)) _( xt -- )_ :: Execute the execution token _xt_.
((>xt)) _( addr -- xt )_ :: Get execution token of word at adress _addr_.

=== Debugging

((words)) :: List all defined words.
((size)) _( "name" -- )_ :: Print the size of the definition of the word named _name_.
((dump)) _( n -- )_ :: Memory dump starting at address _n_.
((n)) :: Continue memory dump where last one stopped.
((see)) _( "name" -- )_ :: Print the definition of the word named _name_. Works on colon definitions only. Optionally included with `include see`.

=== System State

((latest)) _( -- value )_ :: Address of the latest defined header.
((here)) _( -- value )_ :: Write position of the Forth compiler (usually first unused byte of code space).
Many C64 assemblers refer to this as program counter or '*'.
((pad)) _( -- addr )_ :: Address of the `pad`, a 161-byte memory region that can be used freely by user words.
No built-in words will modify this region.

=== Disk I/O

((include)) _( "filename" -- )_ :: Load and parse file. Example: `include test`
((included)) _( filenameptr filenamelen -- )_ :: Load and parse file.
((require)) _( "filename" -- )_ :: Like include, except that load is skipped if the file is already loaded.
((required)) _( filenameptr filenamelen -- )_ :: Like included, except that load is skipped if the file is already loaded.
((loadb)) _( filenameptr filenamelen dst -- endaddr )_ :: Load binary data to _dst_.
Returns 0 on failure, otherwise address after last written byte.
((saveb)) _( start end filenameptr filenamelength -- )_ :: Save binary data.
((device)) _( device# -- )_ :: Switches the active device.
((save-forth)) _( "filename" -- )_ :: Saves the forth to the given filename.
((ls)) :: Load and print disk directory with optional drive # and wildcards. Example: `ls $1:*=p` Load directory for drive 1, only prg files.
((rdir)) _( addr -- )_ :: Display disk directory previously loaded to addr.

==== DOS Commands

Words for sending DOS commands to drives and reading drive status are available by including the `dos` module.

((send-cmd)) _( c-addr u -- )_ :: Writes the given string to secondary address 15 on the current device, and prints the drive's response. The following example defines a word, `backup` that creates a copy of `durexforth` called `backup`:
----
: backup s" copy0:backup=durexforth" send-cmd ;
backup
----

((dos)) ( "cmd" -- )] Sends _cmd_ to the current device's command channel, and prints the response. Note that the remainder of the line is treated as part of the command. This makes it possible to refer to file names that contain spaces, but means that `dos` and its command should be on their own line, or the last words on a line. Example: `dos scratch0:old file` will delete a file named _old file_.

==== Low-Level Device I/O

For more advanced uses, words corresponding to the standard Commodore Kernal IO routines are available by including the `io` module.

((open)) _( filenameptr filenamelength file# secondary-addr -- ioresult )_ :: Open a logical file.
((chkin)) _( file# -- ioresult )_ :: Use a logical file as input device.
((chkout)) _( file# -- ioresult )_ :: Use a logical file as output device.
((clrchn)) _( -- )_ :: Resets input and output to the keyboard and screen.
((close)) _( file# -- )_ :: Close a logical file.
((readst)) _( -- status )_ :: Returns the status of the last IO operation.
For serial-bus devices, `$01` = write timeout, `$02` = read timeout, `$40` = end of file (EOI), `$80` = device not present.
((chrin)) _( -- char)_ :: Reads a character from the current input device.
((ioabort)) _( ioresult -- )_ Handles error conditions for `open`, `chkin` and `chkout`. On failure, print error message and abort.

As per the underlying Kernal routines, `chrin` does not check for end-of-file or any other error condition. `readst` should be called to ensure that the returned character is valid.

The _ioresult_ value returned by `open`, `chkin` and `chkout` is 0 on success, or a Kernal error number if an error occurred.

Note that use of low-level device I/O may interfere with disk accesses done by durexForth and the `v` editor. The following guidelines should be followed to avoid interference:

- Avoid using file numbers 15 and below (remember, any number up to 127 can be used as a file number).
- Only use input/output redirection (`chkin` and `chkout`) within word definitions, and ensure that `clrchn` is called before exit.
- Close files as soon as they are no longer needed.
- If multiple files are open, always call `clrchn` to end any serial bus transactions before calling `open` or switching between files with `chkin` or `chkout`.
